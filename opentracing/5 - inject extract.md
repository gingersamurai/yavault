Программисты, добавляющие поддержку трассировки через границы процессов, должны понимать возможности Tracer.Inject(...) и Tracer.Extract(...) спецификации OpenTracing. Они концептуально мощны, позволяя программисту писать корректный и общий код межпроцессного распространения без привязки к конкретной реализации OpenTracing; однако, с большой силой приходит большая возможность для путаницы :)

Этот документ содержит краткое описание разработки и правильного использования Inject и Extract, независимо от конкретного языка OpenTracing или реализации OpenTracing.

## "Большая картина" для явного распространения трассировки
Самое сложное в распределенной трассировке - это распределенная часть. Любая система трассировки нуждается в способе понимания причинно-следственных связей между действиями во многих различных процессах, независимо от того, связаны ли они через формальные рамки RPC, системы pub-sub, общие очереди сообщений, прямые HTTP-вызовы, UDP-пакеты, передаваемые по принципу best-effort, или что-то другое.

Некоторые распределенные системы трассировки (например, Project5 от 2003 года, WAP5 от 2006 года или The Mystery Machine от 2014 года) выводят причинно-следственные связи через границы процессов. Конечно, существует компромисс между очевидным удобством этих подходов, основанных на умозаключениях "черного ящика", и свежестью и качеством собранных трасс. Если говорить о качестве, то OpenTracing - это явный стандарт инструментария распределенной трассировки, и как таковой он гораздо лучше согласуется с такими подходами, как X-Trace 2007 года, Dapper 2010 года или многочисленными системами трассировки с открытым исходным кодом, такими как Zipkin или Jaeger (среди прочих).

Вместе Inject и Extract позволяют распространять трассировку между процессами без жесткой привязки программиста к конкретной реализации OpenTracing.

## Требования к схеме распространения OpenTracing
Чтобы Inject и Extract были полезны, все следующие условия должны быть верны:

- В соответствии с вышесказанным, пользователю OpenTracing, занимающемуся распространением межпроцессной трассировки, не нужно писать специфичный для реализации OpenTracing код.
- Реализации OpenTracing не должны нуждаться в специальных обработчиках для каждого известного механизма межпроцессного взаимодействия: это слишком много работы, и она даже не вполне определена.
- При этом механизм распространения должен быть расширяемым для оптимизации.

## Основной подход: Inject, Extract и Carriers
Любой SpanContext в трассе может быть Injected в то, что OpenTracing называет носителем. Носитель - это интерфейс или структура данных, которые полезны для межпроцессного взаимодействия (IPC); то есть носитель - это то, что "переносит" состояние трассировки от одного процесса к другому. Спецификация OpenTracing включает два обязательных формата Carrier, хотя возможны и собственные форматы Carrier.

Аналогично, учитывая Carrier, Injected трассировку можно Extract, получив экземпляр SpanContext, семантически идентичный Injected в Carrier.

#### Inject пример псеводокода

```python
span_context = ...
outbound_request = ...

# We'll use the (builtin) HTTP_HEADERS carrier format. We
# start by using an empty map as the carrier prior to the
# call to `tracer.inject`.
carrier = {}
tracer.inject(span_context, opentracing.Format.HTTP_HEADERS, carrier)

# `carrier` now contains (opaque) key:value pairs which we pass
# along over whatever wire protocol we already use.
for key, value in carrier:
    outbound_request.headers[key] = escape(value)
```

#### Extract пример псевдокода

```python
inbound_request = ...

# We'll again use the (builtin) HTTP_HEADERS carrier format. Per the
# HTTP_HEADERS documentation, we can use a map that has extraneous data
# in it and let the OpenTracing implementation look for the subset
# of key:value pairs it needs.
#
# As such, we directly use the key:value `inbound_request.headers`
# map as the carrier.
carrier = inbound_request.headers
span_context = tracer.extract(opentracing.Format.HTTP_HEADERS, carrier)
# Continue the trace given span_context. E.g.,
span = tracer.start_span("...", child_of=span_context)

# (If `carrier` held trace data, `span` will now be ready to use.)
```

## У Носителя есть форматы
Все Носители имеют формат. В некоторых языках OpenTracing формат должен быть указан явно в виде константы или строки; в других языках формат определяется из статической информации о типе Носителя.

## Необходимые форматы Inject/Extract Carrier
Как минимум, все платформы требуют, чтобы реализация OpenTracing поддерживала два формата Carrier: формат "текстовой карты" и "двоичный" формат.

- Формат носителя "текстовая карта" представляет собой идиоматическую для платформы карту из строки (юникод) в строку.
- Двоичный формат Carrier - это непрозрачный массив байтов (и, предположительно, более компактный и эффективный).

То, что реализации OpenTracing выбирают для хранения в этих носителях, формально не определено спецификацией OpenTracing, но предполагается, что они находят способ кодировать "состояние трассировщика" о распространяемом SpanContext (например, в Dapper это будет включать trace_id, span_id и битовую маску, представляющую статус выборки для данной трассы), а также любые элементы багажа ключ:значение.


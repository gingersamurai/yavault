---
title: 'лекция 4-1: Основные концепции System Design'
updated: 2023-04-14 09:05:08Z
created: 2023-04-12 11:18:21Z
latitude: 55.98715260
longitude: 37.20215140
altitude: 0.0000
tags:
  - паттерны проектирования
---

# 1\. Вводная часть

## Характерные черты монолитного подхода

- Избыточность сборок и развертывания
- невозможность масштабирования части приложения
- Увеличение цены сбоя
- Сложность внедрения новых технологий
- Редкость обновлений

<img src="../_resources/8aad99fc9478ae93e86ad37e2f4bec25.png" alt="8aad99fc9478ae93e86ad37e2f4bec25.png" width="380" height="337" class="jop-noMdConv">

## Характерные черты микросервисного подхода

- Простота замены модулей
- Каждый микросервис выполняет только одну задачу
- Независимость программной и аппаратной инфраструктуры модулей
- Приоритет эффективности решений над стандартизацией
- Линейный характер архитектуры

<img src="../_resources/b1b899afb23e3133a1d5d8868f119e6a.png" alt="b1b899afb23e3133a1d5d8868f119e6a.png" width="519" height="461" class="jop-noMdConv">

## Клиент-серверное приложение

### Недостатки:

- Сервер \- узкое место в отношении производительности, единая точка отказа
- Изменить принятое решение о размещении функциональных возможностей после создания системы сложно и дорого

## Условный сервис

Сервис и приложение работают в рамках одного компьютера.

Общение с другими сервисами по http в рамках локальной сети.

<img src="../_resources/ba4f6f23a2970953955bf8c8bc7463be.png" alt="ba4f6f23a2970953955bf8c8bc7463be.png" width="458" height="407" class="jop-noMdConv">

# 2\. Масштабирование

\*\*scale up \*\*- увеличение "размера" и возможностей по обработке нагрузки

\*\*scale down \*\*- уменьшение "размера" и возможностей по обработке нагрузки

<img src="../_resources/c5c7f89bc91c421c87f9905c82c55922.png" alt="c5c7f89bc91c421c87f9905c82c55922.png" width="553" height="325" class="jop-noMdConv">

# 3\. Балансировка нагрузки

1.  Купим/арендуем несколько серверов, запустим сервис на каждом из них
2.  Переведем сервис на отдельный сервер
3.  добавим балансировщик нагрузки

<img src="../_resources/f825ced727067f6b24b2686c326580ef.png" alt="f825ced727067f6b24b2686c326580ef.png" width="517" height="618" class="jop-noMdConv">

## Балансировки нагрузки

*Round robin* \- n-й запрос отправляется на машину с n % num_machines

<img src="../_resources/233555f82055f62bbfa33064c6877d1d.png" alt="233555f82055f62bbfa33064c6877d1d.png" width="474" height="498" class="jop-noMdConv">

*Weightet RR* \- хостам назначаются веса с учетом их коэффициента мощности

<img src="../_resources/98a34cd31311fdb7eba791b5f477e670.png" alt="98a34cd31311fdb7eba791b5f477e670.png" width="474" height="434" class="jop-noMdConv">

*Least Connections / Outstanding Requests* \- выбираем машину с наименьшим количеством незавершенных запросов (Connections) и с минимальным числом сетевых подключений.

<img src="../_resources/3a26135cd3d464c762303f0efa8afb83.png" alt="3a26135cd3d464c762303f0efa8afb83.png" width="508" height="638" class="jop-noMdConv">

*Destination Hash Scheduling и Source Hash Scheduling* \- вычисляем хеш от запроса h, отправляем на машину с номером h % num_machines

<img src="../_resources/851c550bbc71c859ee845fac37cc3d08.png" alt="851c550bbc71c859ee845fac37cc3d08.png" width="477" height="599" class="jop-noMdConv">

Sticky sessions - позволяет закреплять сессию за одним сервером или группой серверов.

<img src="../_resources/01d9d51d9298f32787c4dc75a98c0f2b.png" alt="01d9d51d9298f32787c4dc75a98c0f2b.png" width="195" height="245" class="jop-noMdConv">

# 4\. Кэширование

Cache hit & miss - попадание, не попадание в кеш.

Pull -  после получения данных сохраняем результаты в кэш.

Push - сервер отправляет обновление по данным в кеш.

<img src="../_resources/5205585cbee48b14cd1d3df63de52a43.png" alt="5205585cbee48b14cd1d3df63de52a43.png" width="451" height="249" class="jop-noMdConv">

добавим кеширование для сохранения тяжелых вычислений и переиспользования:

- CDN (content delivery network)
- Key Value (in memory database)

<img src="../_resources/9569d224eada3c8d735c8fecc13f4878.png" alt="9569d224eada3c8d735c8fecc13f4878.png" width="503" height="681">

# 5\. Репликация

Процесс распространения данных для распределенного хранения.

Репликация данных \- храним одни и те же данные на разных репликах, одна реплика на запись, другие на чтение.

<img src="../_resources/294484c2df2152e47373d749d8325f0f.png" alt="294484c2df2152e47373d749d8325f0f.png" width="643" height="419">

**Сильная согласованность (strong consistency)** \- После завершения обновления любой последующий доступ к данным вернет обновленное значение. 

**Согласованность в конечном счете (Eventual consistency). - **В конечном счете все запросы будут возвращать последнее обновленное значение.

Добавим 2 реплики на чтение к базе данных

- Запросы на чтение направляем к read репликам
- Запросы на запись будут обрабатываться master

<img src="../_resources/710f414d39375a7ddfb6fe2115fb4232.png" alt="710f414d39375a7ddfb6fe2115fb4232.png" width="371" height="495">

# 6\. Шардирование

Разбиение базы данных на относительно независимые части.

- Vertical partitioning: разделение таблицы в несколько таблиц в рамках одного сервера
- Horizontal partitioning / sharding: разбиение таблиц и частей таблиц по нескольким серверам

<img src="../_resources/610f839eb4c7b15ee80b8e8360dec988.png" alt="610f839eb4c7b15ee80b8e8360dec988.png" width="479" height="343">

### Перешардирование (resharding)

shard\_number = id % num\_machines - все номера шардов меняются, если меняется num_machines.

Double inc - если добавляем четное количество, то переносим только половину данных (как на рисунке).

Consistent hashing - переносится разница только на удалении двух точек на кольце.

<img src="../_resources/1e7f2ae99d26a90f36eafd0544b1892f.png" alt="1e7f2ae99d26a90f36eafd0544b1892f.png" width="496" height="499">

Добавим шардирование на основе id операции % num_shards

помимо этого шардинг и репликация часто используются совместно.

<img src="../_resources/709fb22572c755759d3bdacac8e514d1.png" alt="709fb22572c755759d3bdacac8e514d1.png" width="497" height="636">

# 7\. Очереди сообщений

Проблема:

- Дать возможность сервисам обрабатывать запросы, когда они освободятся

Решение:

- Используем очереди сообщений для последовательной асинхронной обработки
- пользователю возвращаем ID задания и даем интерфейс для его проверки
- простое масштабирование

<img src="../_resources/baf8440e47e267e04722a65d70f01cc6.png" alt="baf8440e47e267e04722a65d70f01cc6.png" width="590" height="241">

Добавим на схему:

- сервис продюсер для отправки сообщений в очередь
- очередь сообщений
- наши сервисы по мере занятости будут вычитывать сообщения из очереди и обрабатывать

<img src="../_resources/69b59013176c0a68bcc52ce50332db15.png" alt="69b59013176c0a68bcc52ce50332db15.png" width="563" height="742">

# 8\. SQL и NoSQL

### Когда лучше SQL:

- Имеются логические требования к данным, которые могут быть определены заранее.
- Очень важна целостность данных.
- Нужна основанная на устоявшихся стандартах , используя которую можно рассчитывать на большой опыт разработчиков и техническую поддержку. 

### Когда лучше NoSQL:

- Требования к данным нечеткие, неопределенные или развивающиеся с ростом проекта.
- Цель проекта может корректироваться со временем, при этом важна возможность немедденного начала разработки.
- Одни из основных требований к базе данных \- скорость обработки данных и масштабируемость.
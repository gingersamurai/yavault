---
title: 'лекция 2-1: конкурентность и параллелизм'
updated: 2023-04-08 11:34:53Z
created: 2023-03-27 19:21:50Z
latitude: 55.98715260
longitude: 37.20215140
altitude: 0.0000
tags:
  - go
  - операционные системы
---

# 1\. Concurrency vs Parallelism

## Определение

**параллельность** \- несколько потоков одновременно выполняются

**Конкурентность** \- управление передается то одному, то другому

## Проблемы

- непредсказуемость
- синхронизация
- багфикс
- общие хранилища

# 2\. Процессы, потоки, горутины

## Процесс

> \- это отдельная единица исполнения.

### Особенности:

- раздельные ресурсы
- раздельная память
- раздельный стек

ОС и процессы

## до ос:

- нет многозадачности
- нет нескольких процессов =\> нет проблем
- программисты спят спокойно

### после ос:

- многозадачность
- два и более процесса
- программистам не до сна

## Поток

> \- это набор операций, выполняемых независимо в рамках процесса.

### Особенности:

- общие ресурсы
- общая память
- раздельный стек

## Горутины

> \- это легковесный поток внутри потока ОС.

### Особенности:

- общие ресурсы
    
- общая память
    
- общий системный стек
    

### стек:

- горутина \- структура, которая выполняет переданную функцию
    
- самый тяжелый элемент структуры \- *stack*
    
- по умолчанию выделяется 2КБ
    
- в процессе стек может измениться, если потребуется
    
- у стека есть максимальный размер \- 1ГБ для 64бит и 250Кб для 32бит
    

## Пример горутины

```go
func testFunc() int{
    fmt.Println("2 + 2")
}

func main() {
    go testFunc()
    go func() {
        fmt.Println("1 + 1")
    }()
}
```

# 3\. Runtime и планировщик Go

## Runtime

\*\* *m* \*\*\- реальный поток ОС, создается по числу виртуальных процессов

***p*** \- реальный процессор, представляет каждое виртуальное ядро

***g*** \- горутина, создается при необзодимости, как минимум, одна для *main*

*<img src="../_resources/ebcc27879e02c6a7a9b8ab83a1a5781c.png" alt="ebcc27879e02c6a7a9b8ab83a1a5781c.png" width="442" height="272" class="jop-noMdConv">*

## Go Scheduler

управление *g* осуществляется шедулером Go, а не ОС

Переключение **может быть **выполнено, если:

- запускается новая горутина
- собирается мусор
- запускается синхронизация
- происходит системный вызов
- происходит аллокация стека

# Пример

<img src="../_resources/be7a14355f2b5fdb2bec4b8fb06fe25b.png" alt="be7a14355f2b5fdb2bec4b8fb06fe25b.png" width="404" height="298" class="jop-noMdConv">

# 4\. Каналы

> \- механизм взаимодействия между горутинами

содержит информацию:

- размер буфера
- закрыт/открыт
- свзанные горутины
- мьютекс
- и тд

<img src="../_resources/5643b51e56adf072f1e5bca173c313ed.png" alt="5643b51e56adf072f1e5bca173c313ed.png" width="400" height="219" class="jop-noMdConv">

## Небуфферизированные каналы

<img src="../_resources/fdfa5d51b22260f660763d9264e33a6b.png" alt="fdfa5d51b22260f660763d9264e33a6b.png" width="385" height="345" class="jop-noMdConv">

## Deadlock

<img src="../_resources/c930601030e4d65a37e5fe073d2f62ff.png" alt="c930601030e4d65a37e5fe073d2f62ff.png" width="387" height="284" class="jop-noMdConv"> <img src="../_resources/a17dae71175cc9c63978770bb90d4289.png" alt="a17dae71175cc9c63978770bb90d4289.png" width="385" height="245" class="jop-noMdConv">

## Буфферизированные каналы

<img src="../_resources/23f8aa7b38db8eb332c9804db1478ea8.png" alt="23f8aa7b38db8eb332c9804db1478ea8.png" width="389" height="126" class="jop-noMdConv">

## Запись в закрытый канал

- записывать не можем
- читать можем

<img src="../_resources/7c4f5d46b2891e0ade185bece1d1d68e.png" alt="7c4f5d46b2891e0ade185bece1d1d68e.png" width="361" height="115" class="jop-noMdConv">

## Передача в функцию

<img src="../_resources/c3ff3f61bacbd7427bd0c9f00dd13b8d.png" alt="c3ff3f61bacbd7427bd0c9f00dd13b8d.png" width="371" height="253" class="jop-noMdConv">

## Select

<img src="../_resources/6707431f9440cab5b040a7ad343a9b94.png" alt="6707431f9440cab5b040a7ad343a9b94.png" width="369" height="188" class="jop-noMdConv">

# 5\. Примитивы синхронизации

## Mutex, RWMutex

> блокировка для определения возможности доступа к выполнению действия

<img src="../_resources/9cda6f8ccc0e7d78d156cd648d9230c2.png" alt="9cda6f8ccc0e7d78d156cd648d9230c2.png" width="314" height="155" class="jop-noMdConv">

## WaitGroup

> блокировка по счетчику

<img src="../_resources/66baf6c19faa72f41844f356cb6c52d2.png" alt="66baf6c19faa72f41844f356cb6c52d2.png" width="312" height="324" class="jop-noMdConv"> <img src="../_resources/ec096f5501a1c8a67365b5c78abd6864.png" alt="ec096f5501a1c8a67365b5c78abd6864.png" width="308" height="255" class="jop-noMdConv">

## Atomic

- все атомии реализуют `Load`, `Store`, `Swap`. `CompareAndSwap`
- базовые целочисленные атомики также реализуют `Add`
- `Swap(addr *T, new T) T` \- по адресу пишет `new`, возвращает старое значение `addr*`
- `CompareAndSwap(addr *T, old, new T) bool` \- если значение по ссылке равно `old`, то пишет туда `new` и возвращает `true`, иначе `false`

## Context

> передача метаданных по цепочке вызовов и обработка завершения

<img src="../_resources/c8b5368273a6a85389ae19cbd76f41a4.png" alt="c8b5368273a6a85389ae19cbd76f41a4.png" width="527" height="386" class="jop-noMdConv"> 

## Дополнительно из sync

- Cond - ожидает срабатывания условия
- Map - потокобезопасный словарь
- Once - обеспенчивает выполнение функции не более одного раза
- Pool - пул ресурсов для работы

# Итоги

1.  Конкурентность != параллелизм
2.  процесс -> поток -\> горутина
3.  планировщик Go умен и серьезен
4.  каналы \- мощный ниструмент комуникации
5.  примитивы синхронизации \- это просто и очень нужно
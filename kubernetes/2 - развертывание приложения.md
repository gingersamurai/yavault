## Цели
- Узнайте о развертывании приложений.
- Разверните свое первое приложение на Kubernetes с помощью kubectl.
## Развертывания kubernetes
После создания кластера Kubernetes вы можете развернуть на нем свои контейнерные приложения. Для этого вы создаете развертывание(**deployment**) Kubernetes. Развертывание указывает Kubernetes, как создавать и обновлять экземпляры вашего приложения. После создания развертывания плоскость управления Kubernetes планирует запуск экземпляров приложения, включенных в это развертывание, на отдельных узлах кластера.
После создания экземпляров приложений контроллер развертывания Kubernetes непрерывно следит за этими экземплярами. Если узел, на котором находится экземпляр, выходит из строя или удаляется, контроллер развертывания заменяет его экземпляром на другом узле в кластере. Это обеспечивает механизм самовосстановления для решения проблемы сбоя или обслуживания машины.
В дооркестровом мире для запуска приложений часто использовались сценарии установки, но они не позволяли восстанавливаться после сбоя машины. Создавая экземпляры приложений и поддерживая их работу на всех узлах, развертывания Kubernetes обеспечивают принципиально иной подход к управлению приложениями.


## Развертывание первого приложения
![](Pasted%20image%2020230614202138.png)
Вы можете создавать и управлять развертыванием с помощью интерфейса командной строки Kubernetes, kubectl. Kubectl использует Kubernetes API для взаимодействия с кластером. В этом модуле вы изучите наиболее распространенные команды Kubectl, необходимые для создания развертываний, запускающих ваши приложения на кластере Kubernetes.

Когда вы создаете развертывание, вам нужно указать образ контейнера для вашего приложения и количество реплик, которые вы хотите запустить. Вы можете изменить эту информацию позже, обновив развертывание; в модулях 5 и 6 буткемпа рассматриваются способы масштабирования и обновления развертываний.
## Основы kubectl
Общий формат команды kubectl следующий: `kubectl action resource`
Выполняет указанное действие(*action*) (например, создание, описание или удаление) над указанным ресурсом(*resource*) (например, узлом или развертыванием). Вы можете использовать `--help` после подкоманды, чтобы получить дополнительную информацию о возможных параметрах (например: `kubectl get nodes --help`).
Чтобы просмотреть узлы в кластере, выполните команду `kubectl get nodes`.
Вы увидите доступные узлы. Позже Kubernetes выберет, где развернуть наше приложение, основываясь на доступных ресурсах узлов.

## Разверните приложение
Давайте развернем наше первое приложение на Kubernetes с помощью команды `kubectl create deployment`. Нам нужно указать имя развертывания и местоположение образа приложения (включите полный url репозитория для образов, размещенных вне хаба Docker).
```bash
kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
```
Отлично! Вы только что развернули свое первое приложение, создав развертывание. Это выполнило для вас несколько действий:

- поиск подходящего узла, на котором может быть запущен экземпляр приложения (у нас есть только 1 доступный узел)
- запланировали запуск приложения на этом узле
- сконфигурировал кластер, чтобы при необходимости переназначить экземпляр на новый узел

Для получения списка развертываний используйте команду `kubectl get deployments`:

```bash
kubectl get deployments
```

```
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE

kubernetes-bootcamp   1/1     1            1           106s
```
Мы видим, что существует 1 развертывание, в котором запущен один экземпляр вашего приложения. Этот экземпляр запущен внутри контейнера на вашем узле.

## Просмотр приложения

Подсистемы, запущенные внутри Kubernetes, работают в частной, изолированной сети. По умолчанию они видны из других подов и сервисов в пределах одного кластера kubernetes, но не за пределами этой сети. Когда мы используем kubectl, мы взаимодействуем через эндпоинт API для связи с нашим приложением.

Команда `kubectl` может создать прокси, который будет перенаправлять соединения в частную сеть всего кластера. Прокси можно завершить, нажав control-C, и он не будет показывать никаких результатов во время работы.

```bash
kubectl proxy
```

Теперь у нас есть соединение между нашим хостом (онлайн-терминалом) и кластером Kubernetes. Прокси обеспечивает прямой доступ к API с этих терминалов.

Вы можете видеть все эти API, размещенные через эндпоинт прокси. Например, мы можем запросить версию непосредственно через API с помощью команды curl:
```bash
curl http://localhost:8001/version
```

```json
{

  "major": "1",
  "minor": "26",
  "gitVersion": "v1.26.3",
  "gitCommit": "9e644106593f3f4aa98f8a84b23db5fa378900bd",
  "gitTreeState": "clean",
  "buildDate": "2023-03-15T13:33:12Z",
  "goVersion": "go1.19.7",
  "compiler": "gc",
  "platform": "linux/amd64"

}
```
Сервер API автоматически создаст конечную точку для каждого пода на основе имени пода, которое также будет доступна через прокси.

Сначала нам нужно получить имя Pod, которое мы будем хранить в переменной окружения POD_NAME:

```bash
export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
echo Name of the Pod: $POD_NAME
```

```
Name of the Pod: kubernetes-bootcamp-5485cc6795-qkczl
```

Вы можете получить доступ к Pod через проксированный API, выполнив команду:
```bash
curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/
```
[пример вывода](пример%20вывода.md)

Для того чтобы новое развертывание было доступно без использования прокси, необходим сервис, которая будет описана в следующих модулях.


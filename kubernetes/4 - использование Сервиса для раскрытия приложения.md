## Цели
- Узнать про Сервисы в kubernetes
- Понять как метки и селекторы связаны с Сервисом
- Раскрыть приложение из kubernetes кластера используя Сервис

## Обзор Сервисов
Поды Kubernetes смертны. Поды имеют жизненный цикл. Когда рабочий узел умирает, поды, запущенные на этом узле, также теряются. ReplicaSet может динамически возвращать кластер в нужное состояние путем создания новых подов для поддержания работы вашего приложения. В качестве другого примера рассмотрим бэкенд обработки изображений с 3 репликами. Эти реплики взаимозаменяемы; внешнюю систему не должны волновать реплики бэкенда или даже потеря и воссоздание Pod. Однако каждый Pod в кластере Kubernetes имеет уникальный IP-адрес, даже Pod на одном узле, поэтому необходимо предусмотреть способ автоматического согласования изменений между Pod, чтобы ваши приложения продолжали работать.

Сервис в Kubernetes - это абстракция, определяющая логический набор подов и политику доступа к ним. Сервисы обеспечивают тесную связь между зависимыми подами. Сервис определяется с помощью YAML или JSON, как и все манифесты объектов Kubernetes. Набор подов, на которые нацелен Сервис, обычно определяется селектором меток (см. ниже, почему вам может понадобиться Сервис без включения селектора в спецификацию).

Хотя каждый под имеет уникальный IP-адрес, эти IP-адреса не выведены за пределы кластера без Сервиса. Сервисы позволяют вашим приложениям получать трафик. Сервисы могут быть открыты различными способами путем указания *type* в *spec* сервиса:
- ClusterIP (по умолчанию) - Выставляет Сервис на внутренний IP в кластере. Этот тип делает Сервис доступным только изнутри кластера.
- NodePort - Выставляет службу на один и тот же порт каждого выбранного узла в кластере с использованием NAT. Делает Серви доступным из-за пределов кластера, используя `<NodeIP>:<NodePort>`. Является надмножеством ClusterIP.
+  LoadBalancer - Создает внешний балансировщик нагрузки в текущем облаке (если поддерживается) и назначает фиксированный внешний IP для службы. Является надмножеством NodePort.
- ExternalName - Сопоставляет службу с содержимым поля externalName (например, foo.bar.example.com), возвращая запись CNAME с его значением. Никакого проксирования не устанавливается. Для этого типа требуется версия kube-dns v1.7 или выше, или CoreDNS версии 0.0.8 или выше.

Более подробную информацию о различных типах Служб можно найти [тут](https://kubernetes.io/docs/tutorials/services/source-ip/) и [тут](https://kubernetes.io/docs/tutorials/services/connect-applications-service/)

Кроме того, обратите внимание, что есть некоторые сценарии использования Сервисов, которые предполагают отсутствие определения селектора в спецификации. Сервис, созданный без селектора, также не создаст соответствующий объект эндпоинтов. Это позволяет пользователям вручную сопоставлять Сервис с определенными эндпоинтами. Другая возможность отсутствия селектора заключается в том, что вы строго используете type: ExternalName.

## Сервисы и метки

Сервис маршрутизирует трафик через набор подопв. Сервисы - это абстракция, которая позволяет подам умирать и реплицироваться в Kubernetes без влияния на ваше приложение. Обнаружение и маршрутизация между зависимыми Pods (например, frontend и backend компоненты в приложении) обрабатываются Сервисами Kubernetes.

Сервисы сопоставляют набор подов с помощью меток и селекторов - примитива группировки, который позволяет логически оперировать объектами в Kubernetes. Метки представляют собой пары ключ/значение, прикрепленные к объектам, и могут использоваться любым способом:
- Назначение объектов для разработки, тестирования и производства
- Встраивать теги версий
- Классифицируйте объект с помощью тегов

![](Pasted%20image%2020230615124736.png)

Ярлыки могут быть прикреплены к объектам во время создания или позже. Они могут быть изменены в любое время. Давайте теперь откроем наше приложение с помощью службы и применим некоторые метки.

## Создание нового сервиса

Давайте проверим, что наше приложение запущено. Воспользуемся командой `kubectl get` и поищем существующие поды:

```
kubectl get pods
```

Далее, давайте составим список текущих служб нашего кластера:

```
kubectl get services
```

```
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   17h
```

У нас есть Сервис kubernetes, которая создается по умолчанию, когда minikube запускает кластер. Чтобы создать новый Сервис и открыть его для внешнего трафика, мы воспользуемся командой expose с NodePort в качестве параметра.

```
kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080
```

Давайте снова запустим подкоманду get services:

```
kubectl get services
```

Теперь у нас есть запущенный Сервис под названием kubernetes-bootcamp. Здесь мы видим, что Сервис получил уникальный кластерный IP, внутренний порт и внешний IP (IP узла).

Чтобы узнать, какой порт был открыт извне (для типа: NodePort Service), выполним подкоманду describe service:

```
kubectl describe services/kubernetes-bootcamp
```

Создайте переменную окружения под названием NODE_PORT, которой будет присвоено значение порта узла:

```
export NODE_PORT="$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')".
echo "NODE_PORT=$NODE_PORT"
```

```
NODE_PORT=31885
```

Теперь мы можем проверить, что приложение открыто за пределами кластера, используя curl, IP-адрес узла и порт, открытый извне:

```
curl http://"$(minikube ip):$NODE_PORT"
```

И мы получаем ответ от сервера. Служба открыта.

## Используем метки

Развертывание автоматически создало метку для нашего Pod. С помощью подкоманды describe deployment вы можете увидеть имя (ключ) этой метки:

```
kubectl describe deployment
```

Давайте используем эту метку для запроса нашего списка Pods. Используем команду kubectl get pods с параметром -l в качестве параметра, за которым следуют значения меток:

```
kubectl get pods -l app=kubernetes-bootcamp
```

Получите имя пода и сохраните его в переменной окружения POD_NAME:

```
export POD_NAME="$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}}')".
echo "Name of the Pod: $POD_NAME"
```

Чтобы применить новую метку, мы используем подкоманду label, за которой следует тип объекта, имя объекта и новая метка:

```
kubectl label pods "$POD_NAME" version=v1
```

Это применит новую метку к нашему Pod (мы прикрепили версию приложения к Pod), и мы можем проверить его с помощью команды describe pod:

```
kubectl describe pods "$POD_NAME"
```

Здесь мы видим, что ярлык теперь прикреплен к нашему Pod. И теперь мы можем запросить список стручков, используя новый ярлык:

```
kubectl get pods -l version=v1
```

И мы видим под.

## Удаление службы

Для удаления служб можно использовать подкоманду delete service. Здесь также можно использовать метки:

```
kubectl delete service -l app=kubernetes-bootcamp
```
Убедитесь, что служба удалена:

```
kubectl get services
```

Это подтверждает, что наш Сервис был удален. Чтобы подтвердить, что маршрут больше не открыт, вы можете просмотреть ранее открытые IP и порт:

```
curl http://"$(minikube ip):$NODE_PORT"
```

Это доказывает, что приложение больше не доступно извне кластера. Вы можете подтвердить, что приложение все еще работает, выполнив curl изнутри капсулы:

```
kubectl exec -ti $POD_NAME -- curl http://localhost:8080
```

Здесь мы видим, что приложение работает. Это потому, что развертывание управляет приложением. Чтобы выключить приложение, вам нужно будет удалить и развертывание.


